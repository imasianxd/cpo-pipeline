# -*- coding: utf-8 -*-
"""cpo-pipeline.typing.parsers.result_parsers

This module provides functions for parsing result files generated by tools
during the Typing phase of the cpo-pipeline.
"""

import csv

def parse_mlst_result(path_to_mlst_result):
    """
    Args:
        path_to_mlst_result (str): Path to the mlst report file.

    Returns:
        list of dict: Parsed mlst report.
        For example:
        [
            {
                'contig_file': 'SAMPLE-ID.fa',
                'scheme_id': 'ecoli',
                'sequence_type': '405',
                'multi_locus_alleles': {
	            'adk': '35',
	            'fumc': '37',
	            'gyrB': '29',
	            'icd': '25',
	            'mdh': '4',
	            'purA': '5',
	            'recA': '73'
                }
            }
        ]
    """
    mlst_results = []
    #read in the mlst result
    with open(path_to_mlst_result) as mlst_result_file:
        reader = csv.reader(mlst_result_file, delimiter='\t')
        for row in reader:
            mlst_result = {}
            mlst_result['contig_file'] = row[0]
            mlst_result['scheme_id'] = row[1]
            mlst_result['sequence_type'] = row[2]
            mlst_result['multi_locus_alleles'] = {}
            for field in row[3:]:
                (locus, allele) = tuple(field.replace(')', '').split('('))
                mlst_result['multi_locus_alleles'][locus] = allele
            mlst_results.append(mlst_result)
    return mlst_results

def parse_mob_recon_contig_report(path_to_mob_recon_contig_report):
    """
    Args:
        path_to_mob_recon_contig_report (str): Path to the mob_recon contig_report file.

    Returns:
        list of dict: Parsed mob_recon contig_report.
        For example:
        [
            {
                'file_id': 'contigs.fa',
                'cluster_id': '683',
                'contig_id': 'contigs.fa|contig00054_len=2672_cov=424.9_corr=0_origname=NODE_54_length_2672_cov_424.949312_pilon_sw=shovill-spades/1.0.1_date=20181024',
                'contig_length': 2672,
                'circularity_status': 'Incomplete',
                'rep_type': 'IncL/M',
                'rep_type_accession': '000148__NC_021488_00028',
                'relaxase_type': 'MOBP',
                'relaxase_type_accession': 'NC_004464_00056',
                'mash_nearest_neighbor': 'JX988621',
                'mash_neighbor_distance': 0.00560872,
                'repetitive_dna_id': 'KX646543',
                'match_type': 'ISL3',
                'score': 10178.0,
                'contig_match_start': 22,
                'contig_match_end': 5535
            },
            ...
        ]
        Note: several of these fields may be empty for some records.
    """
    def parse_value_maybe(value):
        if value == "":
            return None
        else:
            return value

    # Ideally we would let the csv.DictReader pick these up automatically
    # from the header, but there's a bug in mob_recon that adds extra whitespace
    # in front of 'mash_nearest_neighbor' in the header, so we list them explicitly.
    mob_recon_contig_report_fieldnames = [
        'file_id',
        'cluster_id',
        'contig_id',
        'contig_length',
        'circularity_status',
        'rep_type',
        'rep_type_accession',
        'relaxase_type',
        'relaxase_type_accession',
        'mash_nearest_neighbor',
        'mash_neighbor_distance',
        'repetitive_dna_id',
        'match_type',
        'score',
        'contig_match_start',
        'contig_match_end'
    ]
    mob_recon_contig_report_results = []
    with open(path_to_mob_recon_contig_report) as mob_recon_contig_report_file:
        reader = csv.DictReader(mob_recon_contig_report_file, fieldnames=mob_recon_contig_report_fieldnames, delimiter='\t')
        next(reader) # skip header
        integer_fields = ['contig_length', 'contig_match_start', 'contig_match_end']
        float_fields = ['mash_neighbor_distance', 'score']
        for row in reader:
            for key in row.keys():
                row[key] = parse_value_maybe(row[key])
            for key in integer_fields:
                if row[key]:
                    row[key] = int(row[key])
            for key in float_fields:
                if row[key]:
                    row[key] = float(row[key])
            mob_recon_contig_report_results.append(row)

    return mob_recon_contig_report_results

def parse_mob_recon_mobtyper_aggregate_report(path_to_mob_recon_mobtyper_aggregate_report):
    """
    Args:
        path_to_mob_recon_mobtyper_aggregate_report (str): Path to the mob_recon mobtyper_aggregate_report file.

    Returns:
        list of dict: Parsed mob_recon mobtyper_aggregate_report.
        For example:
        [
            {
                'file_id': 'plasmid_683.fa',
                'num_contigs': 35,
                'total_length': 532060,
                'percent_gc': 52.48656166597752,
                'rep_types': [
                    'IncL/M',
                    'rep_cluster_1254'
                ],
                'rep_type_accessions': [
                    '000148__NC_021488_00028',
                    '000562__KT346360_00001'
                ],
                'relaxase_types': [
                    'MOBP'
                ],
                'relaxase_type_accessions': [
                    'NC_004464_00056'
                ],
                'mpf_type': 'MPF_1',
                'mpf_type_accessions': [
                    'NC_004464_00073',
                    'NC_005246_00069',
                    'NC_019154_00069',
                    'NC_004464_00068',
                    'NC_004464_00066',
                    'NC_019344_00078',
                    'NC_019063_00094',
                    'NC_005246_00057',
                    'NC_004464_00105'
                ],
                'orit_types': [
                    '-'
                ],
                'orit_accessions': [
                    '-'
                ],
                'predicted_mobility': 'Conjugative',
                'mash_nearest_neighbor': 'JX988621',
                'mash_neighbor_distance': 0.00560872,
                'mash_neighbor_cluster': '683'
            },
            ...
        ]
    """
    # A few of the field names in the mobtyper_aggregate_report
    # include special characters '(' and ')' or aren't very descriptive
    # 'gc' -> 'percent_gc' so we list them explicitly here instead of reading
    # from the report header.
    mob_recon_mobtyper_aggregate_report_fieldnames = [
        'file_id',
        'num_contigs',
        'total_length',
        'percent_gc',
        'rep_types',
        'rep_type_accessions',
        'relaxase_types',
        'relaxase_type_accessions',
        'mpf_type',
        'mpf_type_accessions',
        'orit_types',
        'orit_accessions',
        'predicted_mobility',
        'mash_nearest_neighbor',
        'mash_neighbor_distance',
        'mash_neighbor_cluster'
    ]
    mob_recon_mobtyper_aggregate_report_results = []
    with open(path_to_mob_recon_mobtyper_aggregate_report) as mob_recon_mobtyper_aggregate_report_file:
        reader = csv.DictReader(mob_recon_mobtyper_aggregate_report_file,
                                fieldnames=mob_recon_mobtyper_aggregate_report_fieldnames,
                                delimiter='\t')
        next(reader) # skip header
        integer_fields = ['num_contigs', 'total_length']
        float_fields = ['percent_gc', 'mash_neighbor_distance']
        array_fields = [
            'rep_types',
            'rep_type_accessions',
            'relaxase_types',
            'relaxase_type_accessions',
            'mpf_type_accessions',
            'orit_types',
            'orit_accessions'
        ]
        for row in reader:
            for key in integer_fields:
                row[key] = int(row[key])
            for key in float_fields:
                row[key] = float(row[key])
            for key in array_fields:
                row[key] = row[key].split(',')
            mob_recon_mobtyper_aggregate_report_results.append(row)

    return mob_recon_mobtyper_aggregate_report_results


def parse_abricate_result(path_to_abricate_result):
    """
    Args:
        path_to_resfinder_result (str): Path to the abricate report file.
    
    Returns:
        list of dict: Parsed abricate report.
        For example:
        [
            {
                'file': 'contigs.fa',
                'sequence': 'contig00044',
                'start': 3183,
                'end': 3995,
                'gene': 'NDM-1',
                'coverage': '1-813/813',
                'coverage_map': '===============',
                'gaps': '0/0',
                'percent_coverage': 100.00,
                'percent_identity': 100.00,
                'database': 'bccdc',
                'accession': 'CAZ39946.1',
                'product': '  subclass B1 metallo-beta-lactamase NDM-1 '
            },
            ...
        ]
    """
    abricate_report_fieldnames = [
        'file',
        'sequence',
        'start',
        'end',
        'gene',
        'coverage',
        'coverage_map',
        'gaps',
        'percent_coverage',
        'percent_identity',
        'database',
        'accession',
        'product'
    ]
    abricate_report_results = []
    with open(path_to_abricate_result) as abricate_report_file:
        reader = csv.DictReader(abricate_report_file, fieldnames=abricate_report_fieldnames, delimiter='\t')
        next(reader) # skip header
        integer_fields = ['start', 'end']
        float_fields = ['percent_coverage', 'percent_identity']
        for row in reader:
            for key in integer_fields:
                row[key] = int(row[key])
            for key in float_fields:
                row[key] = float(row[key])
            abricate_report_results.append(row)

    return abricate_report_results    


def parse_rgi_result_txt(path_to_rgi_result):
    """
    Args:
        path_to_rgi_report (str): Path to the tabular rgi report file (SAMPLE-ID.rgi.txt).

    Returns:
        list of dict: Parsed rgi report.
        For example:
        [
            {
                'orf_id': 'contig00007_44 # 46711 # 49833 # -1 # ID=7_44;partial=00;start_type=ATG;rbs_motif=AGGAG;rbs_spacer=5-10bp;gc_cont=0.547',
                'contig': 'contig00007_44',
                'start': 46711,
                'stop': 49833,
                'orientation': '-',
                'cut_off': 'Strict',
                'pass_bitscore': 1800,
                'best_hit_bitscore': 1894.78,
                'best_hit_aro': 'mdtB',
                'best_identities': 92.7,
                'aro': '3000793',
                'model_type': 'protein homolog model',
                'snps_in_best_hit_aro': [
                    'S357N',
                    'D350N'
                ],
                'other_snps': None,
                'drug_class': 'aminocoumarin antibiotic',
                'resistance mechanism': 'antibiotic efflux',
                'amr_gene_family': 'resistance-nodulation-cell division (RND) antibiotic efflux pump',
                'predicted_dna': 'ATGCAGGTGTTACCTCCTGACAACACAGGCGGACCATCGC...',
                'predicted_protein': 'MQVLPPDNTGGPSRLFILRPVATTLLMVAILLAGII...',
                'card_protein_sequence': 'MQVLPPSSTGGPSRLFIMRPVATTLLMVAILL...',
                'percentage_length_of_reference_sequence': 100.00,
                'id': 'gnl|BL_ORD_ID|776|hsp_num:0',
                'model_id': '820'
            },
            ...
        ]
    """
    rgi_report_fieldnames = [
        'orf_id',
        'contig',
        'start',
        'stop',
        'orientation',
        'cut_off',
        'pass_bitscore',
        'best_hit_bitscore',
        'best_hit_aro',
        'best_identities',
        'aro',
        'model_type',
        'snps_in_best_hit_aro',
        'other_snps',
        'drug_class',
        'resistance mechanism',
        'amr_gene_family',
        'predicted_dna',
        'predicted_protein',
        'card_protein_sequence',
        'percentage_length_of_reference_sequence',
        'id',
        'model_id'
    ]
    rgi_report_results = []
    
    def parse_value_maybe(value):
        if value == "n/a":
            return None
        else:
            return value
        
    with open(path_to_rgi_result) as rgi_report_file:
        reader = csv.DictReader(rgi_report_file, fieldnames=rgi_report_fieldnames, delimiter='\t')
        next(reader) # skip header
        integer_fields = [
            'start',
            'stop',
        ]
        float_fields = [
            'pass_bitscore',
            'best_hit_bitscore',
            'best_identities',
            'percentage_length_of_reference_sequence'
        ]
        array_fields = [
            'snps_in_best_hit_aro',
            'other_snps'
        ]
        for row in reader:
            for key in integer_fields:
                row[key] = int(row[key])
            for key in float_fields:
                row[key] = float(row[key])
            for key in array_fields:
                # 'n/a' => None
                # 'S80I' => ['S80I']
                # 'S357N, D350N' => ['S357N', 'D350N']
                row[key] = row[key].split(', ') if parse_value_maybe(row[key]) else None
            rgi_report_results.append(row)

    return rgi_report_results
